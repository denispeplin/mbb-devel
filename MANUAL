	0. Basics

Весь комплект состоит из двух частей: mbbd (сервер) и mbbsh (клиент).
Сервер хранит состояние всех объектов (пользователей, адресов и др), имеет
соединение с базой данных, выполняет всю работу по изменению и добавлению
параметров, синхронизируясь с базой, предоставляет доступ по сети для выполнения
команд, имеет отдельный сетевой интерфейс для обработки http сообщений от
браузера для реализации web интерфейса.
Клиент составляет и принимает xml сообщения от сервера, предоставляет
"интуитивно понятный" интерфейс командной строки для реализации команд.

--------------------------------------------------------------------------------

	0.1 mbbd

Аргументы командной строки отсутствуют. Параметры для запуска считываются из
конфигурационного файла .mbbrc из домашней директории запустившего пользователя.
В сервере реализована абстракция переменных: определённо заданные именованные
переменные, хранящие значение указанного типа (число, строка, булевое значение,
директория). Переменные являются параметрами для внутренних функций сервера,
дополнительными аргументами для обработки пользовательских команд или readonly
переменные, описывающие состояние сервера или сессии (например @.peer - хост,
с которого выполнено подключение, @.user - пользователь, под которым выполнена
авторизация).
Переменные подразделяются на две категории:
 - базовые: живут во время работы сервера
 - сессионные: для каждой сессии создается отдельная копия переменной, обычно
 	являются копией одноимённой базовой переменной, после окончанию сессии
	все ресурсы, выделенные на эти переменные, особождаются
Переменные никак не сохраняются в базе данных, после завершения работы сервера
все значения переменных теряются. Изначальные значения переменных можно задавать
в кофигурационном файле.

Основные параметры конфигурационного файла:
	- секция [general] -
	host, port  - адрес и порт, на который принимаются соединения
	http-port - порт приёма http сообщений
	dbtype - значение только postgres
	modules - список модулей, подгружаемых при запуске

	- секция [db] -
	параметры для доступа к базе данных

	- секция [var] -
	значения переменных сервера

	auth.key.lifetime - время жизни ключа авторизации
		(ключ авторизации - метод аутентификации, используемый для
		 web интерфейса, при упешной авторизации пользователь может
		 запросить ключ и выполнять авторизацию не по имени и паролю,
		 а по ключу)
	module.dir - директория с дополнительными модулями

	- секция [cache] -
	значения для переменных модулей

	netflow.data.dir - директория с файлами netflow
	netflow.store.dir - директория, где сохраняется детализация трафика

--------------------------------------------------------------------------------

	0.2 mbbsh

Клиентская программа для доступа к серверу.
$ mbbsh --help	:)

Интерпретатор команд в духе unix shell. Сама программа реализует только
интерфейс командной строки, работу с сетью и интерпретатор lua скриптов.
Описание команд, составление сообщений, вывод результата реализованы на языке
lua отдельными скриптами.
К примеру, добавление unit'а:
	- через mbbsh -
  mbbsh> add unit foobar

  	- lua код -
  tag = mbb.tag "mbb-add-unit"
  tag.name._value = "foobar"
  mbb.request(tag)

Lua скрипты лежать в директории /home/mikeos/.config/mbblua/

Переменная окружения MBB_HOST=addr:port - значения адрес и порта сервера по
умолчанию.

Аргументы командной строки:
	--user - пользователь для авторизации
	--pass - пароль для авторизации, необязательный параметр,
		для использования mbbsh в скриптах
	--host, --serv - адрес и порт сервера

--------------------------------------------------------------------------------

	1. Команды mbbsh

1.1 user - объект авторизации, по параметром которого происходит логин в систему
и выполнение команд на основе прав пользователя.

Группы, к которым пренадлежит пользователь, определяют команды, которые он может
выполнять. Спосок групп (mbbsh> show groups)
	- root - абсолютные права на всё
	- consumer - просмотр собственной статистики
	- log - возможность ловить сообщения логов
> add user $name - создание пользователя $name, запрашивает пароль, дважды
> drop user $name - удаление пользователя
> show users - спосок всех пользователей
> user show groups $name - список групп пользователя $name
> user show consumers $name - список consumer'ов
> user show units $name - список unit'ов
> user mod pass $name - изменение пароля
> user mod name $name $newname - изменение имени на $newname
> self show groups - список групп текущего пользователя

Забегая вперёд:
unit - объект подсчёта трафика, характеризующися списком ip адресов
consumer - логическая группа unit'ов
consumer'у можно поставить в соответствие user'а для доступа статистике

> show groups - список групп
> group show users $group - список пользоваетелей в группе
> group add user $group $user - добавить пользователя в группу
> group del user $group $user - удалить пользователя из группы

/* время
объекты consumer, unit, inet (адрес) имеют значения времени начала и конца
формат времени:
	"%Y-%m-%d %H:%M:%S",
	"%Y-%m-%d %H:%M",
	"%Y-%m-%d %H",
	"%Y-%m-%d",
	"%Y-%m",
	"%Y",
	now - текущее время,
	inf - неограниченное начало или конец
	parent - время родителя

Иерархия объектов:
user -> consumer -> unit -> inet
То есть user содержит несколько consumer'ов, consumer - несколько unit'ов и т.д.

unit и inet могут наследовать время родителя
к примеру:
	consumer: 2010-01-01 inf
	unit: parent parent
	inet: parent parent

в этом случае start и end время у inet есть время consumer'а
при изменении времени consumer'а (> consumer mod time end 2010-02-01) у всех
дочерних объектов время изменится соответственно

Но unit и inet могут иметь так же собственное независимое от родителя время

Отображение времени:
	{time} - собственное
	^time^ - наследованное
*/

1.2 unit - точка подсчёта трафика

unit имеет параметры времени: начала и конца, возможно родительские, если
привязан к определённому consumer'у

> add unit $name - добавить unit
> drop unit $name - удалить unit
> show units [$regex] - список unit'ов, соответствующих $regex
> unit add inet $unit $inet - добавить адрес $inet, время действия адреса будет
	текущим
> unit add inherit int $unit $inet - аналогично, только время действия адреса
	будет зависить от родителя
> unit show inet $unit - список адресов unit'а
> unit drop inet $inet_id - удалть адрес по id
> unit clear inet $unit - удалить все адреса unit'а

> unit map rebuild $unit - перестроить карту адресов unit'а, если выдаёт ошибки,
	значить адреса пересекаются
> unit map showall $unit - вывести карту адресов
Зачем нужна эта map нужна, объясню ниже

> unit set consumer $unit $consumer - добавить unit к consumer'у
> unit detach $unit - отсоединтить unit от своего consumer'а

> unit mod name $name $newname - изменение имени
> unit mod time start/end $name $time - изменение времени начала/конца unit'а
> unit inet mod time start/end $inet_id - изменение времени начала/конца адреса

1.3 consumer - группа unit'ов

consumer имеет параметры времени: начала и конца

> add consumer $name - добавить consumer
> drop consumer $name - удалить consumer
> show consumers [$regex] - списко consumer'ов, соответствующих $regex
> consumer mod name $name $newname - очевидно
> consumer mod time start/end $name - очевидно
> consumer set user $cons $user - добавить consumer'а указанному user'у
> consumer detach $name - отсоединить consumer'а от его user'а
> consumer show units $name - вывести список unit'ов
> consumer add unit $cons $unit - создать нового unit'а, присоединённого к
	указанному consumer'у
> consumer add inherit unit $cons $unit - аналогично, но время начала созданного
	unit'а будет родительским

1.4 map

для подсчёта трафика используются не непосредственные адреса unit'ов,
а адреса в главной карте адресов (map)

Алгоритм действий таков:
> add unit foo
> unit add inherit inet foo 192.168.0.0/24
> unit add inherit inet foo 127.0.0.1/8
> unit map rebuild foo
> unit map showall foo
> map add foo - добавить адреса foo в главную карту, но перед этим необходимо
	перестроить локальную карту unit'а
> map show unit foo - вывести адреса foo как они есть в главной карте
если все команды молчат, значит всё хорошо

Следующие команды:
> show nomapped - список unit'ов, которые не внесены, этого быть не должно
> map rebuild - перестроить карты всех unit'ов и добавить их адреса в главную,
	если никто не забывает выполнять действия предыдущего алгоритма, то
	в этой команде нет необходимости

1.5 логи

> show session - список текущих подключений

Реализованы каналы сообщений, на манер подписки

> server log showall - список всех каналов

msg - сообщения о вызове методов, создании, удалении объектов, информационные
	сообщения без категории
xml - мониторинг протокола общения с сервером (как на самом деле происходит
	взаимодействие)
http - мониторинг взимодействия с web интерфейсом
task - сообщения от фоновых задач (например обработка netflow файлов, которая
	происхлдит раз в час)
query - мониторинг всех sql запросов (кроме запросов сохранения статистики в
	базе данных)
self - сообщения от собственной сессии
user - сообщения от пользователей

> log on - подписка на msg
> log add [chan ..] - добавить каналы
> log del [chan ..] - удалить каналы
> log set [chan ..] - установить только эти каналы
> log show - список текущий каналов
> log off - отменить все подписки

> log push $msg - послать сообщения в канал user, все кто подписался на этот
	канал его получат

По умолчанию подписавшемуся потоку приходят сообщения с соответствующих каналов
ото всех остальных сессий, но только не от себя же. Для получения собстенных
сообщений надо добавить канал self

Также есть механизм фильтрации сообщений только для определённых сессий

> log trace add [sid ..] - добавить id сессий для фильтрации
> log trace del [sid ..] - соответственно удалить
> log trace show - список фильтруемых сессий
> log trace clean - удалить фильтры, но оставить каналы
> log trace zclean - удалить все несуществующие сессии (просто так, чтобы было)
> log trace add self - получать сообщения только от себя
	в то время как "log add self" значит получать ото всех и от себя

1.6 внутренние команды для оболочки

внутренние команды не автодополняются

> help - список всех команд

все команды представляют собой древовидную иерархию на манер файловой системы
и автоополнение не единственный способ для выбора конкретной команды.

по аналогии с файловой системой есть команды ls и cd для навигации по командам
Пример:
> show <Tab> <Tab> - список всех show команд
> show users - список юзеров
или
> cd show
[/show]> <Tab> <Tab> - только show команды
[/show]> users - список юзеров

"cd /" или "cd" - перейти в корень
cd .. - очевидно

> exec cmd [args] - выполнить внешнюю программу (но локальную)
> echo $msg - аналог echo, для работы в скриптах
> clear - это для того чтобы делать ls/clear, ls/clear, ls/clear ...
	Макс (olfronar) знает

> info on/off - включить/отключить вывод информации о lua реализации команд
При включении для каждой команды становятся доступны следующий аргументы:
--def - описание lua функции, соответствующей команде
--info - информация о функции: файл, метод, строка, название функции
--source - исходник

к примеру:
> add unit --source
> log on --info
> map reload --source
